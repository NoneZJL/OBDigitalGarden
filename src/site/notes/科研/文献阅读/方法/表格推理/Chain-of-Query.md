---
{"dg-publish":true,"permalink":"/科研/文献阅读/方法/表格推理/Chain-of-Query/"}
---

#方法 #表格问答 #Agent 

>[!abstract] 论文概述 [Chain-of-Query: Unleashing the Power of LLMs in SQL-Aided Table Understanding via Multi-Agent Collaboration](https://arxiv.org/abs/2508.15809)
>
>近年来，多智能体 SQL 生成框架在解决理解表格数据的挑战方面展现出潜力，但现有方法常常存在诸如无法理解表结构以实现可靠 SQL 生成、错误传播导致查询无效以及过度依赖执行正确性等局限性。
>
>为了解决这些问题，文章提出了链查询（Chain-of-Query，简称 CoQ），这是一种用于 SQL 辅助表格理解的多智能体框架。CoQ 采用自然语言风格的表格模式，以抽象结构噪声并增强理解。采用逐条的 SQL 生成策略来提升查询质量，并引入了混合推理，将基于 SQL 的机械推理与基于 LLM 的逻辑推理区分开来，从而减少对执行结果的依赖。
>
>仓库链接：[SongyuanSui/ChainofQuery](https://github.com/SongyuanSui/ChainofQuery)

## Introduction

SQL 本质上设计用于访问、过滤和汇总关系表格中的信息，因此与表格理解的需求高度契合。文章总结了 SQL 辅助表格理解在大语言模型中的三大关键挑战。

1. 现有方法通常将表格和任务指令输入 LLM，前提是 LLM 能够理解表，从而生成有意义的 SQL。然而，如果 LLM 本身旧在表格理解方面有困难，那么它很可能一开始就无法生成准确的 SQL。因此，这种工作流程继承了 LLM 结构上的不足，因为有效的 SQL 生成仍需对表的布局和语义有扎实的理解——而这正是 LLM 本身所缺乏的。
2. 支持复杂的多步推理通常需要包含多个子句和嵌套结构的 SQL 查询。此类查询难以在一次处理中正确构造，即使是小错误也可能连锁导致查询失败。
3. 现有方法高度依赖 SQL 执行的正确性，因为它们直接将 SQL 结果作为最终答案。这进一步导致大型语言模型生成过于复杂的查询，从而降低整体可靠性。

为了应对这些挑战，文章提出了链查询（Chain-of-Query），一种用于 SQL 辅助表格理解的新型多代理框架。

- 为解决第一个挑战，CoQ 用*表格模式的自然语言*表示代替了原始表格输入。文章认为 SQL 生成主要依赖于高级模式，这些模式可以用自然语言轻松准确地表达，绕过了 LLM 解释复杂表格的需求。这种抽象使得 LLM 能够专注于语义，而不会被噪声或不规则的布局所阻碍。
- 为应对第二个挑战，文章提出*一种逐句 SQL 生成策略*，逐步构建 SQL 查询，形成一系列逐步精炼的查询链。
- 为解决第三个挑战，设计了一种*混合推理分工策略*，将机械推理（通过 SQL 执行）与逻辑推理（让 LLM 回答）分离，将 SQL 输出视为中间步骤而非最终答案。

## Chain-of-Query Approach

### Problem Definition of Table Understanding

给定一个二元组 $X = (Q, T)$，其中 $Q$ 是自然语言问题，$T=\{S,D\}$ 是由模式 $S$ 和数据内容 $D$ 组成的表，表格理解的目标是识别回答问题 $Q$ 所需的相关子集 $D_r \subseteq D$，然后通过 $Q$ 和 $D_r$ 生成回答 $A$。这里，模式 $S$ 描述了表的结构，同时 $D$ 包含各个单元格级的值。

### Overview of Chain-of-Query

![[attenchments/Pasted image 20251211143642.png#pic_center]]

CoQ 将表格理解分解为模块化子任务，每个代理为其分配的角色调用专用策略。如图 1 所示，它由四个专用代理组成：*语义分割器*、*SQL 查询生成器*、*动态规划器*和*答案生成器*，每个代理负责流水线的不同阶段。语义分裂器构建自然语言风格的表格模式，并将问题分解为并行子问题。SQL 查询生成器应用了逐句 SQL 生成策略。动态规划器采用了混合推理分步策略。答案生成器根据 SQL 输出和 LLM 的推断综合最终答案。

### Semantic Splitter: Schema Abstraction and Query Decomposition

语义分割器是整个代理工作流程的入口。该模块旨在优化 SQL 生成的输入，解决两个关键挑战：

（1）LLM 解释复杂表结构的能力有限，这常导致 SQL 生成不准确;
（2）单个复杂查询中子问题之间的干扰，其中独立子问题可以单独处理以避免纠缠。

为应对这些挑战，引入了自然语言风格的表模式表示以生成查询，并采用并行分解机制识别和隔离可分离子查询以实现执行。

#### Natural-Language-Style Table Schema

文章认为：SQL 生成主要依赖于高层模式信息，而非详细的表内容，用自然语言表达模式更符合 LLM 作为语言模型的优势。

文章构建了一个简明的自然语言风格模式作为全表输入的替代。它由三个组成部分组成：`table_name`、`headers` 和 `value examples`。表名称使用简洁的关键词总结表的主要内容和目的，为 LLM 理解表提供了必要的上下文。表头由多个（列名、列值类型）对组成。这些对不仅提供了表结构的自然语言抽象，还作为下游 SQL 生成值格式的参考。值示例是表中几行采样后，配对对应的列名。

#### Parallel Decomposition

语义分解器的第二个组件是并行分解器，专注于将输入问题分离为独立的子问题。与传统的顺序分解策略不同，传统中每个子问题依赖于前一个答案，且因错误传播而变得脆弱，文章的方法侧重于无依赖的问题。

许多复杂的表格问题涉及比较或汇总语义上不相交的表区域的信息，这些区域不需要顺序推理。为此，平行分解器将此类问题拆分为独立的子问题，每个子问题针对表格的局部区域。这消除了步骤间的依赖，并支持并发处理。

### Clause-wise SQL Generation for Precision and Robustness

![[attenchments/Pasted image 20251211150817.png#pic_center | 500]]

SQL 查询生成器构建可执行的 SQL 查询，以检索与任务相关的中间信息并支持机械推理。

#### SQL Query Generation with Validation

根据模式和子问题，LLM 首先生成 SQL 查询以获取相关信息。查询直接通过 SQL 执行程序进行验证；如果失败，错误消息会传递给二级 LLM 进行纠正。修订后的查询会被重新执行，如果成功，则转发到动态规划器。

#### Clause-by-Clause SQL Generation

为了提高 SQL 生成的可靠性和可控性，文章提出了一种逐句策略，通过隔离每个子句的构造，逐步构建查询。生成器首先生成一个基本的 SELECT-FROM 查询，选择与子问题相关的列。然而，如果没有条件过滤，该查询可能会返回大量行，从而带来可扩展性的挑战。为缓解这一问题，采样了几行代表性行（类似于自然语言风格的表模式构建），因为规划器只需观察数据模式而非精确值。

后续操作（如 WHERE、GROUP BY）在动态规划器的指导下依次添加。通过将 SQL 构造分解为离散从句，每一步都专注于自身的逻辑和语法，独立于完整的查询上下文。每个中间查询都会经过验证后才能继续。如果执行失败，错误可以追溯到最近添加的操作，从而实现更有针对性的纠正。如果纠正失败，代理会恢复到最后验证过的查询，确保鲁棒性。如图 2 所示，如果新生成的子句引入查询错误（SQL2）且无法解决，代理使用最后有效查询（SQL1）来确保 SQL 可执行。这一增量过程形成一条越来越精确的查询链，每一步都建立在经过验证的状态之上，防止错误传播并确保稳定性。

### Balancing SQL and LLM Reasoning through Dynamic Planning

动态规划器会逐步检查每个新生成的查询及其执行结果，以判断当前子表是否足以支持 LLM 推理。如果子表仍包含无关或间接信息，规划器会选择另一个 SQL 子句，并请求 SQL 生成器将其附加到当前查询中。规划者由基于充分性的早期停止机制指导。它与答案生成器共同实现了混合推理分工策略：SQL 负责机械推理，而大型语言模型则对中间结果进行逻辑推理以生成最终答案。

#### Hybrid Reasoning Division Strategy

引入了混合推理分工策略，将表格理解分解为两个阶段：机械推理（如过滤、算术）被交付给 SQL，而逻辑推理（如比较、推理）由大型语言模型（LLM）处理。SQL 执行结果被视为中间数据，使大型语言模型能够在 SQL 输出上应用更强的推理能力，得出最终答案。

#### Sufficiency-based Early Stopping

![[attenchments/Pasted image 20251211154540.png#pic_center | 350]]

为支持这种混合推理策略，引入了基于充分性的早期停止机制。它使规划器能够在检索到的数据足够时停止子句生成。这避免了不必要的 SQL 复杂性。

### Answer Generator

答案生成器通过汇总每个子问题的子答案来生成最终答案。它首先根据对应的 SQL 结果生成一个子答案，然后将所有子答案合并成对原始问题的完整自然语言回答。作为流程的最后阶段，这一组成部分确保本地推理结果被连贯地整合进统一的自然语言响应中。

## Experiments

*整体结果*

![[attenchments/Pasted image 20251211160045.png#pic_center]]

![[attenchments/Pasted image 20251211160450.png#pic_center | 350]]

表 1 是在 WTQ 和 TabFact 上的结果，表 2 是在 FeTaQA 上的结果。可以看到 CoQ 始终实现了更高的答案准确性和更低的 SQL 错误率。在 WikiTQ 上，使用 GPT-3.5 后达到 74.77%，比第二高的提升+13.66%。在 TabFact 上，该指数获得了 92.31%，比最佳基线高出+10.39%。在 FeTaQA 上，CoQ 报告了最高的 BLEU（22.19）和 ROUGE 分数（R-1：0.65，R-2：0.42，R-L：0.54），错误率最低（7.74%）。

*泛化性*

![[attenchments/Pasted image 20251211162513.png#pic_center]]

为了进一步测试方法在现实场景中的效果，在 IM-TQA 和 Open-WikiTable 数据集上进行了额外实验（IM-TQA 包含结构多样化的表（转置、嵌套和不规则格式），而 Open-WikiTable 则反映多表数据库在实际应用中）。

表 4 就是对应的实验结果，可以看到 CoQ 在结构复杂度和多表环境中均保持良好表现。

*消融实验*

![[attenchments/Pasted image 20251211162751.png#pic_center | 400]]

表 5 是在 WTQ 数据集上消融实验的结果。

- 移除自然语言风格模式会导致明显的性能下降（–10.12%）和更多无效的 SQL（+1.13%）。这凸显了抽象结构噪声的好处。
- 去除并行任务分解会导致准确率略有下降（–1.82%），表明其对简单情况的影响有限，但在复杂情况下则有用。
- 禁用逐条 SQL 生成会导致准确率大幅下降（–17.04%），无效 SQL 数量急剧上升（+5.48%），因为从句级生成支持增量验证和准确选择子句。这降低了错误查询的风险，并确保应用了适当的 SQL 作。
- 最大的下降（–18.81%）出现在没有混合推理的情况下，该模块防止了过度生成，并将逻辑推理委托给了 LLM。没有这种控制，系统往往会过度生成，增加查询复杂度，而不会提升答案质量。

*模型调用次数*

![[attenchments/Pasted image 20251211163007.png#pic_center | 400]]

表 6 是 WTQ 数据集上不同方法的每题理论调用次数。

在所有方法中，CoQ 在推理深度和 LLM 使用之间提供了有利权衡，最多需要 22 次调用。相比之下，其他强基线由于分支繁复且步数固定，需要 25 至 100 次调用。虽然 MAC-SQL 稍微更高效（19 次调用内），但在复杂任务中表现不佳。

![[attenchments/Pasted image 20251211163319.png#pic_center | 400]]

图 8 展示的是 CoQ 方法在 WTQ 数据集上的实际模型调用次数结果图，平均每个实例调用 7.63 次，中位数为 5 次。

*不同模型*

![[attenchments/Pasted image 20251211163545.png#pic_center]]
